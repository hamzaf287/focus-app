import cv2
import time
import threading
import os
from flask import Flask, render_template, Response, request, send_file

session_start = None
app = Flask(__name__)

# Paths for saving
VIDEO_DIR = "static/videos"
REPORT_DIR = "static/reports"
os.makedirs(VIDEO_DIR, exist_ok=True)
os.makedirs(REPORT_DIR, exist_ok=True)

# Load OpenCV Haar cascades
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_eye.xml")

camera = None
recording = False
timeline_log = []
video_writer = None

def generate_frames():
    global camera, recording, video_writer, timeline_log
    last_status = "None"

    while True:
        if not recording or camera is None:
            time.sleep(0.1)
            continue

        ret, frame = camera.read()
        if not ret:
            break

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        faces = face_cascade.detectMultiScale(gray, 1.1, 4)
        status = "Distracted"

        for (x, y, w, h) in faces:
            roi_gray = gray[y:y+h, x:x+w]
            eyes = eye_cascade.detectMultiScale(roi_gray)
            if len(eyes) >= 1:
                status = "Focused"
            cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)

        # Log when status changes
        if status != last_status:
            timeline_log.append(f"{time.strftime('%H:%M:%S')} - {status}")
            last_status = status

        # Write frame to video
        if video_writer:
            video_writer.write(frame)

        # Encode to stream
        ret, buffer = cv2.imencode('.jpg', frame)
        frame = buffer.tobytes()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')

@app.route('/')
def index():
    return render_template("index.html")

@app.route('/video_feed')
def video_feed():
    return Response(generate_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/start', methods=["POST"])
def start_recording():
    global camera, recording, video_writer, timeline_log, session_start, session_end
    if not recording:
        camera = cv2.VideoCapture(0)

        # Force faster capture
        camera.set(cv2.CAP_PROP_FPS, 30)
        camera.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

        fourcc = cv2.VideoWriter_fourcc(*'XVID')
        video_path = os.path.join(VIDEO_DIR, f"session_{int(time.time())}.avi")
        video_writer = cv2.VideoWriter(video_path, fourcc, 30.0, (640, 480))

        timeline_log = [f"Session started at {time.strftime('%H:%M:%S')}"]
        recording = True
        session_start = time.time()
        session_end = None
    return "Recording started"



@app.route('/stop', methods=["POST"])
def stop_recording():
    global camera, recording, video_writer, timeline_log, session_start
    if recording:
        recording = False
        if camera:
            camera.release()
        if video_writer:
            video_writer.release()
        camera = None
        video_writer = None

        # Compute summary
        session_end = time.time()
        duration = int(session_end - session_start) if session_start else 0
        total_frames = len(timeline_log)
        focused_frames = sum(1 for e in timeline_log if "Focused" in e)
        distracted_frames = sum(1 for e in timeline_log if "Distracted" in e)
        focus_pct = (focused_frames / total_frames * 100) if total_frames > 0 else 0

        report_path = os.path.join(REPORT_DIR, f"report_{int(time.time())}.txt")
        with open(report_path, "w") as f:
            f.write("===== Focus Report =====\n")
            f.write(f"Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Session Duration: {duration} seconds\n")
            f.write(f"Total Frames Analyzed: {total_frames}\n")
            f.write(f"Focused Frames: {focused_frames}\n")
            f.write(f"Distracted Frames: {distracted_frames}\n")
            f.write(f"Focus Percentage: {focus_pct:.2f}%\n")

        timeline_log = []
        session_start = None

    return "Recording stopped"



@app.route('/download_report')
def download_report():
    files = sorted(os.listdir(REPORT_DIR))
    if not files:
        return "No report found"
    latest = os.path.join(REPORT_DIR, files[-1])
    return send_file(latest, as_attachment=True)

@app.route('/download_video')
def download_video():
    files = sorted(os.listdir(VIDEO_DIR))
    if not files:
        return "No video found"
    latest = os.path.join(VIDEO_DIR, files[-1])
    return send_file(latest, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
